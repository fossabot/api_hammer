#!/usr/bin/env ruby

require 'rubygems'
require 'faraday'
require 'logger'
require 'yaml'

require 'api_hammer/faraday/outputter'

# OPTION PARSER 

require 'optparse'

# $options default values
$options = {
  :verbose => true,
  :color => nil,
  :no_ssl_verify => false,
  :headers => {},
}

$oauth = {}

opt_parser = OptionParser.new do |opts|
  opts.banner = "Usage: #{$0} [options] <verb> <url> [body]"

  opts.on("-v", "--[no-]verbose", "Run verbosely - output is like curl -v (this is the default)") do |v|
    $options[:verbose] = v
  end
  opts.on("-q", "Run quietly - only outputs the response body (same as --no-verbose)") do |v|
    $options[:verbose] = !v
  end
  opts.on("--[no-]color", "Color the output (defaults to color if the output device is a TTY)") do |v|
    $options[:color] = v
  end
  opts.on("-t", "--content-type CONTENT-TYPE", "Sets the Content-Type header of the request") do |v|
    $options[:headers]['Content-Type'.downcase] = v
  end
  opts.on("--oauth-token TOKEN") do |token|
    $oauth[:token] = token
  end
  opts.on("--oauth-token-secret TOKEN_SECRET") do |token_secret|
    $oauth[:token_secret] = token_secret
  end
  opts.on("--oauth-consumer-key CONSUMER_KEY") do |consumer_key|
    $oauth[:consumer_key] = consumer_key
  end
  opts.on("--oauth-consumer-secret CONSUMER_SECRET") do |consumer_secret|
    $oauth[:consumer_secret] = consumer_secret
  end
  opts.on("--oauth-signature-method SIGNATURE_METHOD") do |signature_method|
    $oauth[:signature_method] = signature_method
  end

  opts.on("--no-ssl-verify", "Disables SSL verification - use cautiously!") do
    $options[:no_ssl_verify] = true
  end
  opts.on("-H", "--header HEADER", "Set a header") do |header|
    if header =~ /\A([^:]+):\s*(.*)\z/m # this could be more strictly conformant to rfc, but whatever
      field_name = $1
      field_value = $2
      $options[:headers][field_name.downcase] = field_value
    else
      abort "bad header value given: #{header}"
    end
  end
end
opt_parser.parse!
abort(opt_parser.help) unless (2..3).include?(ARGV.size)

# CONFIGURE THE FARADAY CONNECTION 
faraday_options = {}
if $options[:no_ssl_verify]
  faraday_options[:ssl] = {:verify => false}
end
connection = Faraday.new(faraday_options) do |builder|
  if $oauth.any?
    $oauth[:signature_method] ||= 'HMAC-SHA1'
    require 'oauthenticator'
    OAuthenticator::FaradaySigner
    builder.use OAuthenticator::FaradaySigner, $oauth
  end
  builder.use($options[:verbose] ? FaradayCurlVOutputter : FaradayOutputter, $options)
  builder.adapter Faraday.default_adapter
end

httpmethod, url, body = *ARGV

unless Faraday::Connection::METHODS.map{|m| m.to_s.downcase }.include?(httpmethod.downcase)
  abort "Unrecognized HTTP method given: #{httpmethod}\n\n" + opt_parser.help
end

headers = $options[:headers]
if body && !headers['Content-Type'.downcase]
  # I'd rather not have a default content-type, but if none is set then the HTTP adapter sets this to 
  # application/x-www-form-urlencoded anyway. application/json is a better default for our purposes. 
  headers['Content-Type'.downcase] = 'application/json'
end

# OH LOOK IT'S FINALLY ACTUALLY CONNECTING TO SOMETHING

response = connection.run_request(httpmethod.downcase.to_sym, url, body, headers)
